"""Получатель принимает три шифртекста ШЧУССАЫИЬКВУКРНЬЭЫАЩ, ЫЗБМЕЧБВВЙОФЖЩЕВНЦЛК, ШДШТЫЮОЫБРЙЙВЯСНШШЬХ,
полученные шифрованием сообщения ПРИМЕНЯЯКРИПТОГРАФИЮ композиционным шифром (сначала шифр модульного гаммирования, затем
блочный шифр в режиме CFB с Е(х) = (¬((х ➔ 1) ⋀ Со)⋀Со, Со = 29 и размером блока 5 бит) с различными ключевыми словами в гамме. Определить
идентификатор получателя если номер каждой из его букв равен средней длине соответствующего принятого шифртекста, необходимой для
однозначного восстановления истинного ключевого слова без каких-либо ограничений на время его нахождения."""

import cryptolib as cl

def get_key(text):
    C = abc[c0] + text
    C = cl.word_to_num(abc, C)
    text = cl.word_to_num(abc, text)
    word = []
    for i in range(len(mess)):
        T = cl.zero_fill(list(cl.toBin(int(C[i]))),5)
        Ts = cl.zero_fill(list(cl.toBin(int(text[i]))),5)
        M = cl.zero_fill(list(cl.toBin(int(mess[i]))),5)
        E = cl.AND(cl.inverse(cl.AND(cl.shiftE2F(T, 1), C0)),C0)
        word += cl.num_to_word(abc, cl.XOR(M, cl.XOR(E, Ts)))
    return word

mess = "ПРИМЕНЯЯКРИПТОГРАФИЮ"

t = ["ШЧУССАЫИЬКВУКРНЬЭЫАЩ", "ЫЗБМЕЧБВВЙОФЖЩЕВНЦЛК", "ШДШТЫЮОЫБРЙЙВЯСНШШЬХ"]
abc = "ЭЪЫЬЮАЯБЖНЛФКХИЙПЕМДОГЦРСТУВЧШЩЗ"
c0 = 29

"""
t = ["ЫНЧДЙЦКЮЖТСТЗЭБГЫЦДЯ", "КЭНЫТТИТЫЖМАДИНЖЫТГЗ", "ЛЪЬМЗМОЬЕШЗЫФНФДЮОРШ"]
abc = "ЭЪЫЬХАЯБЖНЕФПЮИЙМЛКУОГЦРСТДВЧШЩЗ"
c0 = 10 """

mess = cl.word_to_num(abc, mess)
C0 = cl.zero_fill(list(cl.toBin(int(c0))),5)

for word in t:
    print(get_key(word))

for i in range(3):
    print("Длина ", (i+1), ":", abc[int(int(input())//0.726)])
